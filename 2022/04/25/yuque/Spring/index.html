

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="JOSWAY">
  <meta name="keywords" content="">
  
    <meta name="description" content="Spring FrameworkXmind 版本:Spring.xmind 控制反转(IoC)容器Inversion of ControlSpring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans，我们将在下一章中进行讨">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring">
<meta property="og:url" content="https://blog.josway.cc/2022/04/25/yuque/Spring/index.html">
<meta property="og:site_name" content="JOSWAY&#39;S BLOG">
<meta property="og:description" content="Spring FrameworkXmind 版本:Spring.xmind 控制反转(IoC)容器Inversion of ControlSpring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans，我们将在下一章中进行讨">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-25T14:47:15.000Z">
<meta property="article:modified_time" content="2023-03-29T14:50:13.932Z">
<meta property="article:author" content="JOSWAY">
<meta property="article:tag" content="spring boot">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Spring - JOSWAY&#39;S BLOG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.josway.cc","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>JOSWAY</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Spring"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-25 22:47" pubdate>
          2022年4月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          102 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Spring</h1>
            
            
              <div class="markdown-body">
                
                <p>Spring Framework<br>Xmind 版本:<a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2022/xmind/28199557/1650898862195-d777bad9-529a-48dd-9939-eb06943a7ece.xmind?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2022/xmind/28199557/1650898862195-d777bad9-529a-48dd-9939-eb06943a7ece.xmind%22,%22name%22:%22Spring.xmind%22,%22size%22:368645,%22type%22:%22%22,%22ext%22:%22xmind%22,%22status%22:%22done%22,%22taskId%22:%22u0c52d2e9-430a-4f52-99b6-de930009419%22,%22taskType%22:%22upload%22,%22id%22:%22u23414779%22,%22card%22:%22file%22%7D">Spring.xmind</a></p>
<h2 id="控制反转-IoC-容器"><a href="#控制反转-IoC-容器" class="headerlink" title="控制反转(IoC)容器"></a>控制反转(IoC)容器</h2><p>Inversion of Control<br>Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans，我们将在下一章中进行讨论。</p>
<p>通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注释或 Java 代码来表示。下图是 Spring 如何工作的高级视图。 Spring IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。</p>
<p>IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常 new 一个实例，控制权由程序员控制，而”控制反转”是指 new 实例工作不由程序员来做而是交给 Spring 容器来做。在 Spring 中 BeanFactory 是 IOC 容器的实际代表者。</p>
<p>ApplicationContext 容器包括 BeanFactory 容器的所有功能，所以通常不建议使用 BeanFactory。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。</p>
<h3 id="BeanFactory-容器"><a href="#BeanFactory-容器" class="headerlink" title="BeanFactory 容器"></a>BeanFactory 容器</h3><p>这是一个最简单的容器，它主要的功能是为依赖注入 （DI） 提供支持，这个容器接口在 org.springframework.beans.factory.BeanFactory 中被定义。BeanFactory 和相关的接口，比如 BeanFactoryAware、DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。</p>
<p>在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。</p>
<p>在资源宝贵的移动设备或者基于 applet 的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext，除非你有更好的理由选择 BeanFactory。</p>
<ul>
<li>org.springframework.beans.factory.xml.XmlBeanFactory<br>这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。</li>
<li>org.springframework.beans.factory.BeanFactoryAware<ul>
<li>setBeanFactory(BeanFactory beanFactory)</li>
</ul>
</li>
<li>org.springframework.beans.factory.DisposableBean<ul>
<li>destory()</li>
</ul>
</li>
<li>org.springframework.beans.factory.InitializingBean<ul>
<li>afterPropertiesSet()</li>
</ul>
</li>
</ul>
<h3 id="ApplicationContext-容器"><a href="#ApplicationContext-容器" class="headerlink" title="ApplicationContext 容器"></a>ApplicationContext 容器</h3><p>Application Context 是 BeanFactory 的子接口，也被称为 Spring 上下文。</p>
<p>Application Context 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。这个容器在 org.springframework.context.ApplicationContext interface 接口中定义。</p>
<p>ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。当然，BeanFactory 仍可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。</p>
<p>最常被使用的 ApplicationContext 接口实现：</p>
<ul>
<li>org.springframework.context.support.FileSystemXmlApplicationContext</li>
<li>org.springframework.context.support.ClassPathXmlApplicationContext</li>
<li>WebXmlApplicationContext</li>
</ul>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><ul>
<li>定义<br>被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。<br>bean 定义包含称为配置元数据的信息，下述容器也需要知道配置元数据：<br>如何创建一个 bean<br>bean 的生命周期的详细信息<br>bean 的依赖关系<ul>
<li>class<br>这个属性是强制性的，并且指定用来创建 bean 的 bean 类。</li>
<li>name<br>这个属性指定唯一的 bean 标识符。在基于 XML 的配置元数据中，你可以使用 ID 和&#x2F;或 name 属性来指定 bean 标识符。</li>
<li>scope<br>这个属性指定由特定的 bean 定义创建的对象的作用域，它将会在 bean 作用域的章节中进行讨论。</li>
<li>constructor-arg<br>它是用来注入依赖关系的。</li>
<li>properties<br>它是用来注入依赖关系的。</li>
<li>autowiring mode<br>它是用来注入依赖关系的</li>
<li>lazy-initialization mode<br>延迟初始化的 bean 告诉 IoC 容器在它第一次被请求时，而不是在启动时去创建一个 bean 实例。</li>
<li>initialization 方法<br>在 bean 的所有必需的属性被容器设置之后，调用回调方法。</li>
<li>destruction 方法<br>当包含该 bean 的容器被销毁时，使用回调方法。</li>
</ul>
</li>
<li>作用域<br>当在 Spring 中定义一个 bean 时，你必须声明该 bean 的作用域的选项。例如，为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 prototype。同理，如果你想让 Spring 在每次需要时都返回同一个 bean 实例，你应该声明 bean 的作用域的属性为 singleton。<br>Spring 框架支持以下五个作用域，分别为 singleton、prototype、request、session 和 global session，5 种作用域说明如下所示。<ul>
<li>singleton<br>在 spring IoC 容器仅存在一个 Bean 实例，Bean 以单例方式存在，默认值</li>
<li>prototype<br>每次从容器中调用 Bean 时，都返回一个新的实例，即每次调用 getBean()时，相当于执行 newXxxBean()</li>
<li>request<br>每次 HTTP 请求都会创建一个新的 Bean，该作用域仅适用于 WebApplicationContext 环境</li>
<li>session<br>同一个 HTTP Session 共享一个 Bean，不同 Session 使用不同的 Bean，仅适用于 WebApplicationContext 环境</li>
<li>global-session<br>一般用于 Portlet 应用环境，该作用域仅适用于 WebApplicationContext 环境</li>
</ul>
</li>
<li>生命周期<br>理解 Spring bean 的生命周期很容易。当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。<br>尽管还有一些在 Bean 实例化和销毁之间发生的活动，但是本章将只讨论两个重要的生命周期回调方法，它们在 bean 的初始化和销毁的时候是必需的。<br>为了定义安装和拆卸一个 bean，我们只要声明带有 init-method 和&#x2F;或 destroy-method 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。<br>Bean 的生命周期可以表达为：Bean 的定义——Bean 的初始化——Bean 的使用——Bean 的销毁<ul>
<li>初始化回调<ul>
<li>org.springframework.beans.factory.InitializingBean<ul>
<li>afterPropertiesSet()</li>
</ul>
</li>
</ul>
</li>
<li>销毁回调<ul>
<li>org.springframework.beans.factory.DisposableBean<ul>
<li>destroy()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>后置处理器<br>Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。<br>BeanPostProcessor 接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。你也可以在 Spring 容器通过插入一个或多个 BeanPostProcessor 的实现来完成实例化，配置和初始化一个 bean 之后实现一些自定义逻辑回调方法。<br>你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。<br>BeanPostProcessor 可以对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口进行它们的工作。<ul>
<li>org.springframework.beans.factory.config.BeanPostProcessor<br>ApplicationContext 会自动检测由 BeanPostProcessor 接口的实现定义的 bean，注册这些 bean 为后置处理器，然后通过在容器中创建 bean，在适当的时候调用它。<br>在你自定义的的 BeanPostProcessor 接口实现类中，要实现以下的两个抽象方法  BeanPostProcessor.postProcessBeforeInitialization(Object, String) 和  BeanPostProcessor.postProcessAfterInitialization(Object, String) 和，注意命名要准确<br>否则会出现： “ The type InitHelloWorld must implement the inherited abstract method BeanPostProcessor.postProcessBeforeInitialization(Object, String) ”之类的错误 - Object postProcessBeforeInitialization(Object bean, String beanName) - Object postProcessAfterInitialization(Object bean, String beanName)</li>
</ul>
</li>
<li>定义继承<br>bean 定义可以包含很多的配置信息，包括构造函数的参数，属性值，容器的具体信息例如初始化方法，静态工厂方法名，等等。<br>子 bean 的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。<br>Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。你可以定义一个父 bean 的定义作为模板和其他子 bean 就可以从父 bean 中继承所需的配置。<br>当你使用基于 XML 的配置元数据时，通过使用父属性，指定父 bean 作为该属性的值来表明子 bean 的定义。</li>
</ul>
<h2 id="依赖注入-DI"><a href="#依赖注入-DI" class="headerlink" title="依赖注入(DI)"></a>依赖注入(DI)</h2><p>Dependency Injection<br>每个基于应用程序的 java 都有几个对象，由这些对象一起工作来呈现出终端用户所看到的工作的应用程序。当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能独立于其他 Java 类来增加这些类重用的可能性，并且在做单元测试时，测试独立于其他类的独立性。依赖注入（或有时称为布线）有助于把这些类粘合在一起，同时保持他们独立。</p>
<h3 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h3><p>当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。</p>
<h3 id="基于设值函数的依赖注入"><a href="#基于设值函数的依赖注入" class="headerlink" title="基于设值函数的依赖注入"></a>基于设值函数的依赖注入</h3><p>当容器调用一个无参的构造函数或一个无参的静态 factory 方法来初始化你的 bean 后，通过容器在你的 bean 上调用设值函数，基于设值函数的 DI 就完成了。</p>
<h3 id="注入内部-Beans"><a href="#注入内部-Beans" class="headerlink" title="注入内部 Beans"></a>注入内部 Beans</h3><p>正如你所知道的 Java 内部类是在其他类的范围内被定义的，同理，inner beans 是在其他 bean 的范围内定义的 bean。因此或元素中的元素称为内部 bean。</p>
<h3 id="注入集合"><a href="#注入集合" class="headerlink" title="注入集合"></a>注入集合</h3><p>你已经看到了如何使用 value 属性来配置基本数据类型和在你的 bean 配置文件中使用标签的 ref 属性来配置对象引用。这两种情况下处理奇异值传递给一个 bean。</p>
<p>现在如果你想传递多个值，如 Java Collection 类型 List、Set、Map 和 Properties，应该怎么做呢。为了处理这种情况，Spring 提供了四种类型的集合的配置元素，如下所示。</p>
<ul>
<li>它有助于连线，如注入一列值，允许重复。</li>
<li>它有助于连线一组值，但不能重复。</li>
<li><pre><code class="hljs"> 它可以用来注入名称-值对的集合，其中名称和值可以是任何类型。
</code></pre>
</li>
<li><pre><code class="hljs"> 它可以用来注入名称-值对的集合，其中名称和值都是字符串类型。
</code></pre>
</li>
</ul>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="自动装配-byName"><a href="#自动装配-byName" class="headerlink" title="自动装配 byName"></a>自动装配 byName</h3><p>这种模式由属性名称指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 auto-wire 属性设置为 byName。然后，它尝试将它的属性与配置文件中定义为相同名称的 beans 进行匹配和连接。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。</p>
<p>例如，在配置文件中，如果一个 bean 定义设置为自动装配 byName，并且它包含 spellChecker 属性（即，它有一个 setSpellChecker(…) 方法），那么 Spring 就会查找定义名为 spellChecker 的 bean，并且用它来设置这个属性。你仍然可以使用   标签连接其余的属性。</p>
<h3 id="自动装配-byType"><a href="#自动装配-byType" class="headerlink" title="自动装配 byType"></a>自动装配 byType</h3><p>这种模式由属性类型指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 autowire 属性设置为 byType。然后，如果它的 type 恰好与配置文件中 beans 名称中的一个相匹配，它将尝试匹配和连接它的属性。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。</p>
<p>例如，在配置文件中，如果一个 bean 定义设置为自动装配 byType，并且它包含 SpellChecker 类型的 spellChecker 属性，那么 Spring 就会查找定义名为 SpellChecker 的 bean，并且用它来设置这个属性。你仍然可以使用   标签连接其余属性。下面的例子将说明这个概念，你会发现和上面的例子没有什么区别，除了 XML 配置文件已经被改变。</p>
<h3 id="由构造函数自动装配"><a href="#由构造函数自动装配" class="headerlink" title="由构造函数自动装配"></a>由构造函数自动装配</h3><p>这种模式与 byType 非常相似，但它应用于构造器参数。Spring 容器看作 beans，在 XML 配置文件中 beans 的 autowire 属性设置为 constructor。然后，它尝试把它的构造函数的参数与配置文件中 beans 名称中的一个进行匹配和连线。如果找到匹配项，它会注入这些 bean，否则，它会抛出异常。</p>
<p>例如，在配置文件中，如果一个 bean 定义设置为通过构造函数自动装配，而且它有一个带有 SpellChecker 类型的参数之一的构造函数，那么 Spring 就会查找定义名为 SpellChecker 的 bean，并用它来设置构造函数的参数。你仍然可以使用   标签连接其余属性。</p>
<h2 id="Web-MVC-框架"><a href="#Web-MVC-框架" class="headerlink" title="Web MVC 框架"></a>Web MVC 框架</h2><p>MVC 框架提供了模型-视图-控制的体系结构和可以用来开发灵活、松散耦合的 web 应用程序的组件。MVC 模式导致了应用程序的不同方面(输入逻辑、业务逻辑和 UI 逻辑)的分离，同时提供了在这些元素之间的松散耦合。</p>
<p>模型封装了应用程序数据，并且通常它们由 POJO 组成。</p>
<p>视图主要用于呈现模型数据，并且通常它生成客户端的浏览器可以解释的 HTML 输出。</p>
<p>控制器主要用于处理用户请求，并且构建合适的模型并将其传递到视图呈现。</p>
<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p>Spring Web 模型-视图-控制（MVC）框架是围绕 DispatcherServlet 设计的，DispatcherServlet 用来处理所有的 HTTP 请求和响应。Spring Web MVC DispatcherServlet 的请求处理的工作流程：</p>
<p>下面是对应于 DispatcherServlet 传入 HTTP 请求的事件序列：</p>
<p>收到一个 HTTP 请求后，DispatcherServlet 根据 HandlerMapping 来选择并且调用适当的控制器。</p>
<p>控制器接受请求，并基于使用的 GET 或 POST 方法来调用适当的 service 方法。Service 方法将设置基于定义的业务逻辑的模型数据，并返回视图名称到 DispatcherServlet 中。</p>
<p>DispatcherServlet 会从 ViewResolver 获取帮助，为请求检取定义视图。</p>
<p>一旦确定视图，DispatcherServlet 将把模型数据传递给视图，最后呈现在浏览器中。<br>上面所提到的所有组件，即 HandlerMapping、Controller 和 ViewResolver 是 WebApplicationContext 的一部分，而 WebApplicationContext 是带有一些对 web 应用程序必要的额外特性的 ApplicationContext 的扩展。</p>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>一个数据库事务是一个被视为单一的工作单元的操作序列。这些操作应该要么完整地执行，要么完全不执行。事务管理是一个重要组成部分，RDBMS 面向企业应用程序，以确保数据完整性和一致性。事务的概念可以描述为具有以下四个关键属性说成是 ACID：</p>
<h3 id="org-springframework-transaction-PlatformTransactionManager"><a href="#org-springframework-transaction-PlatformTransactionManager" class="headerlink" title="org.springframework.transaction.PlatformTransactionManager"></a>org.springframework.transaction.PlatformTransactionManager</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>原子性<br>事务应该当作一个单独单元的操作，这意味着整个序列操作要么是成功，要么是失败的。</li>
<li>一致性<br>这表示数据库的引用完整性的一致性，表中唯一的主键等。</li>
<li>隔离性<br>可能同时处理很多有相同的数据集的事务，每个事务应该与其他事务隔离，以防止数据损坏。</li>
<li>持久性<br>一个事务一旦完成全部操作后，这个事务的结果必须是永久性的，不能因系统故障而从数据库中删除。</li>
</ul>
<h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><p>这意味着你在编程的帮助下有管理事务。这给了你极大的灵活性，但却很难维护。</p>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p>这意味着你从业务代码中分离事务管理。你仅仅使用注释或 XML 配置来管理事务。</p>
<h3 id="事务管理的五大属性"><a href="#事务管理的五大属性" class="headerlink" title="事务管理的五大属性"></a>事务管理的五大属性</h3><ul>
<li>隔离级别</li>
<li>传播行为</li>
<li>是否只读</li>
<li>事务超时</li>
<li>回滚规则</li>
</ul>
<h2 id="JDBC-框架"><a href="#JDBC-框架" class="headerlink" title="JDBC 框架"></a>JDBC 框架</h2><p>在使用普通的 JDBC 数据库时，就会很麻烦的写不必要的代码来处理异常，打开和关闭数据库连接等。但 Spring JDBC 框架负责所有的低层细节，从开始打开连接，准备和执行 SQL 语句，处理异常，处理事务，到最后关闭连接。</p>
<p>所以当从数据库中获取数据时，你所做的是定义连接参数，指定要执行的 SQL 语句，每次迭代完成所需的工作。</p>
<p>Spring JDBC 提供几种方法和数据库中相应的不同的类与接口。我将给出使用 JdbcTemplate 类框架的经典和最受欢迎的方法。这是管理所有数据库通信和异常处理的中央框架类。</p>
<h3 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h3><p>JdbcTemplate 类执行 SQL 查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。它也捕获 JDBC 异常并转换它们到 org.springframework.dao 包中定义的通用类、更多的信息、异常层次结构。</p>
<p>JdbcTemplate 类的实例是线程安全配置的。所以你可以配置 JdbcTemplate 的单个实例，然后将这个共享的引用安全地注入到多个 DAOs 中。</p>
<p>使用 JdbcTemplate 类时常见的做法是在你的 Spring 配置文件中配置数据源，然后共享数据源 bean 依赖注入到 DAO 类中，并在数据源的设值函数中创建了 JdbcTemplate。</p>
<h3 id="SimpleJdbcCall"><a href="#SimpleJdbcCall" class="headerlink" title="SimpleJdbcCall"></a>SimpleJdbcCall</h3><p>SimpleJdbcCall 类可以被用于调用一个包含 IN 和 OUT 参数的存储过程。你可以在处理任何一个 RDBMS 时使用这个方法，就像 Apache Derby， DB2， MySQL， Microsoft SQL Server， Oracle，和 Sybase。</p>
<h2 id="面向切面编程-AOP"><a href="#面向切面编程-AOP" class="headerlink" title="面向切面编程(AOP)"></a>面向切面编程(AOP)</h2><p>Spring 框架的一个关键组件是面向方面的编程(AOP)框架。面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。跨一个应用程序的多个点的功能被称为横切关注点，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。</p>
<p>在 OOP 中，关键单元模块度是类，而在 AOP 中单元模块度是方面。依赖注入帮助你对应用程序对象相互解耦和 AOP 可以帮助你从它们所影响的对象中对横切关注点解耦。AOP 是像编程语言的触发物，如 Perl，.NET，Java 或者其他。</p>
<p>Spring AOP 模块提供拦截器来拦截一个应用程序，例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>Aspect<br>一个模块具有一组提供横切需求的 APIs。例如，一个日志模块为了记录日志将被 AOP 方面调用。应用程序可以拥有任意数量的方面，这取决于需求。</li>
<li>Join point<br>在你的应用程序中它代表一个点，你可以在插件 AOP 方面。你也能说，它是在实际的应用程序中，其中一个操作将使用 Spring AOP 框架。</li>
<li>Advice<br>这是实际行动之前或之后执行的方法。这是在程序执行期间通过 Spring AOP 框架实际被调用的代码。</li>
<li>Pointcut<br>这是一组一个或多个连接点，通知应该被执行。你可以使用表达式或模式指定切入点正如我们将在 AOP 的例子中看到的。</li>
<li>Introduction<br>引用允许你添加新方法或属性到现有的类中。</li>
<li>Target object<br>被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。</li>
<li>Weaving<br>Weaving 把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。</li>
</ul>
<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><ul>
<li>前置通知<br>在一个方法执行之前，执行通知。</li>
<li>后置通知<br>在一个方法执行之后，不考虑其结果，执行通知。</li>
<li>返回后通知<br>在一个方法执行之后，只有在方法成功完成时，才能执行通知。</li>
<li>抛出异常后通知<br>在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</li>
<li>环绕通知<br>在建议方法调用之前和之后，执行通知。</li>
</ul>
<h3 id="基于-AOP-的-XML-架构"><a href="#基于-AOP-的-XML-架构" class="headerlink" title="基于 AOP 的 XML 架构"></a>基于 AOP 的 XML 架构</h3><h3 id="基于-AOP-的-AspectJ"><a href="#基于-AOP-的-AspectJ" class="headerlink" title="基于 AOP 的 @AspectJ "></a>基于 AOP 的 <a href="/AspectJ">@AspectJ </a></h3><p><a href="/AspectJ">@AspectJ </a> 作为通过 Java 5 注释注释的普通的 Java 类，它指的是声明 aspects 的一种风格。通过在你的基于架构的 XML 配置文件中包含以下元素，<a href="/AspectJ">@AspectJ </a> 支持是可用的。</p>
<p>aop:aspectj-autoproxy&#x2F;</p>
<h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><p>从 Spring 2.5 开始就可以使用注解来配置依赖注入。而不是采用 XML 来描述一个 bean 连线，你可以使用相关类，方法或字段声明的注解，将 bean 配置移动到组件类本身。</p>
<p>在 XML 注入之前进行注解注入，因此后者的配置将通过两种方式的属性连线被前者重写。</p>
<p>注解连线在默认情况下在 Spring 容器中不打开。因此，在可以使用基于注解的连线之前，我们将需要在我们的 Spring 配置文件中启用它。</p>
<h3 id="Required-注解"><a href="#Required-注解" class="headerlink" title="@Required  注解"></a><a href="/Required">@Required </a> 注解</h3><p><a href="/Required">@Required </a> 注释应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常。下面显示的是一个使用 <a href="/Required">@Required </a> 注释的示例。</p>
<h3 id="Autowired-注解"><a href="#Autowired-注解" class="headerlink" title="@Autowired  注解"></a><a href="/Autowired">@Autowired </a> 注解</h3><p>使用 Spring 开发时，进行配置主要有两种方式，一是 xml 的方式，二是 java config 的方式。Spring 技术自身也在不断的发展和改变，从当前 Springboot 的火热程度来看，java config 的应用是越来越广泛了，在使用 java config 的过程当中，我们不可避免的会有各种各样的注释打交道，其中，我们使用最多的注释应该就是 <a href="/Autowired">@Autowired </a> 注释了。这个注释的功能就是为我们注入一个定义好的 bean。</p>
<p><a href="/Autowired">@Autowired </a> 注释的作用到底是什么？</p>
<p><a href="/Autowired">@Autowired </a> 这个注释我们经常在使用，现在，我想问的是，它的作用到底是什么呢?</p>
<p>首先，我们从所属范围来看，事实上这个注释是属于 Spring 的容器配置的一个注释，与它同属容器配置的注释还有：@Required,@Primary, <a href="/Qualifier">@Qualifier </a> 等等。因此 <a href="/Autowired">@Autowired </a> 注释是一个用于容器 ( container ) 配置的注释。</p>
<p>其次，我们可以直接从字面意思来看，<a href="/autowired">@autowired </a> 注释来源于英文单词 autowire,这个单词的意思是自动装配的意思。自动装配又是什么意思？这个词语本来的意思是指的一些工业上的用机器代替人口，自动将一些需要完成的组装任务，或者别的一些任务完成。而在 Spring 的世界当中，自动装配指的就是使用将 Spring 容器中的 bean 自动的和我们需要这个 bean 的类组装在一起。</p>
<h3 id="Qualifier-注解"><a href="#Qualifier-注解" class="headerlink" title="@Qualifier  注解"></a><a href="/Qualifier">@Qualifier </a> 注解</h3><p>可能会有这样一种情况，当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 <a href="/Qualifier">@Qualifier </a> 注释和 <a href="/Autowired">@Autowired </a> 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。</p>
<h3 id="JSR-250-注解"><a href="#JSR-250-注解" class="headerlink" title="JSR-250 注解"></a>JSR-250 注解</h3><p>Spring 还使用基于 JSR-250 注释，它包括 @PostConstruct， <a href="/PreDestroy">@PreDestroy </a> 和 <a href="/Resource">@Resource </a> 注释。因为你已经有了其他的选择，尽管这些注释并不是真正所需要的，但是关于它们仍然让我给出一个简短的介绍。</p>
<ul>
<li><a href="/PostConstruct">@PostConstruct </a> 注释 和 <a href="/PreDestroy">@PreDestroy </a> 注解<br>为了定义一个 bean 的安装和卸载，我们使用 init-method 和&#x2F;或 destroy-method 参数简单的声明一下 。init-method 属性指定了一个方法，该方法在 bean 的实例化阶段会立即被调用。同样地，destroy-method 指定了一个方法，该方法只在一个 bean 从容器中删除之前被调用。<br>你可以使用 <a href="/PostConstruct">@PostConstruct </a> 注释作为初始化回调函数的一个替代，<a href="/PreDestroy">@PreDestroy </a> 注释作为销毁回调函数的一个替代，其解释如下示例所示。</li>
<li><a href="/Resource">@Resource </a> 注解<br>你可以在字段中或者 setter 方法中使用 <a href="/Resource">@Resource </a> 注释，它和在 Java EE 5 中的运作是一样的。<a href="/Resource">@Resource </a> 注释使用一个 ‘name’ 属性，该属性以一个 bean 名称的形式被注入。</li>
</ul>
<h3 id="基于-Java-的配置"><a href="#基于-Java-的配置" class="headerlink" title="基于 Java 的配置"></a>基于 Java 的配置</h3><p>到目前为止，你已经看到如何使用 XML 配置文件来配置 Spring bean。如果你熟悉使用 XML 配置，那么我会说，不需要再学习如何进行基于 Java 的配置是，因为你要达到相同的结果，可以使用其他可用的配置。</p>
<p>基于 Java 的配置选项，可以使你在不用配置 XML 的情况下编写大多数的 Spring，但是一些有帮助的基于 Java 的注解，解释如下：</p>
<ul>
<li><a href="/Configuration">@Configuration </a> 和 <a href="/Bean">@Bean </a> 注解<br>带有 <a href="/Configuration">@Configuration </a> 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。<a href="/Bean">@Bean </a> 注解告诉 Spring，一个带有 <a href="/Bean">@Bean </a> 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。<ul>
<li>initMethod()</li>
<li>destroyMethod()</li>
</ul>
</li>
<li><a href="/Import">@Import </a> 注解<br><a href="/import">@import </a> 注解允许从另一个配置类中加载 <a href="/Bean">@Bean </a> 定义。</li>
<li><a href="/Scope">@Scope </a> 注解<br>默认范围是单实例，但是你可以重写带有 <a href="/Scope">@Scope </a> 注解的该方法。</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>你已经看到了在所有章节中 Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。例如，当上下文启动时，ContextStartedEvent 发布，当上下文停止时，ContextStoppedEvent 发布。</p>
<p>通过 ApplicationEvent 类和 ApplicationListener 接口来提供在 ApplicationContext 中处理事件。如果一个 bean 实现 ApplicationListener，那么每次 ApplicationEvent 被发布到 ApplicationContext 上，那个 bean 会被通知。</p>
<p>由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。</p>
<ul>
<li>ContextRefreshedEvent<br>ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext 接口中使用 refresh() 方法来发生。</li>
<li></li>
</ul>
<p>ContextStartedEvent</p>
<p>当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p>
<ul>
<li>ContextStoppedEvent<br>当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</li>
<li>ContextClosedEvent<br>当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</li>
<li>RequestHandledEvent<br>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。</li>
</ul>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Spring%E7%9F%A5%E8%AF%86/" class="category-chain-item">Spring知识</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/spring-boot/">#spring boot</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Spring</div>
      <div>https://blog.josway.cc/2022/04/25/yuque/Spring/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>JOSWAY</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年4月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/25/yuque/Spring%20Boot%201.%20%E6%80%BB%E8%A7%88-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7/" title="Spring Boot 1. 总览-核心特性">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring Boot 1. 总览-核心特性</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/25/yuque/React%20%E5%85%A5%E9%97%A8/" title="React 入门">
                        <span class="hidden-mobile">React 入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
